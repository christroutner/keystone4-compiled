{
  "_args": [
    [
      {
        "raw": "grappling-hook@3.0.0",
        "scope": null,
        "escapedName": "grappling-hook",
        "name": "grappling-hook",
        "rawSpec": "3.0.0",
        "spec": "3.0.0",
        "type": "version"
      },
      "/home/connextcms/test/node_modules/keystone"
    ]
  ],
  "_from": "grappling-hook@3.0.0",
  "_id": "grappling-hook@3.0.0",
  "_inCache": true,
  "_location": "/grappling-hook",
  "_nodeVersion": "0.12.4",
  "_npmUser": {
    "name": "creynders",
    "email": "camille.reynders@gmail.com"
  },
  "_npmVersion": "2.10.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "grappling-hook@3.0.0",
    "scope": null,
    "escapedName": "grappling-hook",
    "name": "grappling-hook",
    "rawSpec": "3.0.0",
    "spec": "3.0.0",
    "type": "version"
  },
  "_requiredBy": [
    "/keystone"
  ],
  "_resolved": "https://registry.npmjs.org/grappling-hook/-/grappling-hook-3.0.0.tgz",
  "_shasum": "4dbf91791ddd620bb0f54b513e479931d453fbf6",
  "_shrinkwrap": null,
  "_spec": "grappling-hook@3.0.0",
  "_where": "/home/connextcms/test/node_modules/keystone",
  "author": {
    "name": "Camille Reynders"
  },
  "bugs": {
    "url": "https://github.com/keystonejs/keystone-hooks/issues"
  },
  "dependencies": {
    "async": "^0.9.0",
    "lodash": "^3.9.3"
  },
  "description": "Pre/Post hooking mechanism",
  "devDependencies": {
    "bluebird": "^2.9.25",
    "coveralls": "^2.11.2",
    "eslint": "^0.23.0",
    "grunt": "^0.4.5",
    "grunt-gh-pages": "^0.10.0",
    "istanbul": "^0.3.15",
    "jsdoc": "^3.3.2",
    "mocha": "^2.2.5",
    "must": "^0.12.0",
    "require-directory": "^2.1.0",
    "sinon": "^1.14.1"
  },
  "directories": {},
  "dist": {
    "shasum": "4dbf91791ddd620bb0f54b513e479931d453fbf6",
    "tarball": "https://registry.npmjs.org/grappling-hook/-/grappling-hook-3.0.0.tgz"
  },
  "gitHead": "2692fcc5239d70c2723c914dea97d937c4ce43f7",
  "homepage": "https://github.com/keystonejs/keystone-hooks",
  "keywords": [
    "events",
    "hooks",
    "async",
    "keystone"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "creynders",
      "email": "camille.reynders@gmail.com"
    },
    {
      "name": "jedwatson",
      "email": "jed.watson@me.com"
    }
  ],
  "name": "grappling-hook",
  "optionalDependencies": {},
  "readme": "# grappling-hook\n[![Build Status](https://travis-ci.org/keystonejs/grappling-hook.svg)](https://travis-ci.org/keystonejs/grappling-hook)\n[![npm version](https://badge.fury.io/js/grappling-hook.svg)](http://npmjs.org/packages/grappling-hook)\n[![Coverage Status](https://coveralls.io/repos/keystonejs/grappling-hook/badge.svg?branch=master)](https://coveralls.io/r/keystonejs/grappling-hook?branch=master)\n\n>pre/post hooking enabler\n\n`grappling-hook` allows you to add pre/post hooks to objects and prototypes.\nA number of modules already exist that allow you to do just the same, but the most popular one ([hooks](https://www.npmjs.com/package/hooks)) is no longer maintained.\nAlso, we wanted a more granular control of the hooking process and the way middleware is called.\n\n**NEW:**\n\n* since v3.0 you can [use promises as middleware][thenable-middleware] and have [thenable hooks][thenable-hooks] (i.e. promise returning hooks).\n* since v2.4 you can [wrap sync methods and call sync hooks][synchronous-hooks].\n* since v2.3 you can [configure `grappling-hook` to use other method names][other-qualifiers] than `pre` or `post`, e.g. `before` and `after`.\n\n## Installation\n\n```sh\n$ npm install grappling-hook\n```\n\n## Usage\n\nFrom here on `grappling-hook` refers to the module itself (i.e. what you get when you `require('grappling-hook')`) and `GrapplingHook` refers to any GrapplingHook object (i.e. an object which allows you to register `pre` and `post` middleware, et cetera)\n\n`grappling-hook` and `GrapplingHook` expose two different API's:\n\n1. a consumer-facing API, i.e. it allows you to add middleware functions to pre/post hooks.\n1. a producer-facing API, i.e. it allows you to create hooks, wrap methods with hooks, et cetera.\n\n### Consumer-facing API\n\nAllows you to add/remove [middleware][middleware] functions to hooks. There's 4 types of middleware possible:\n\n#### synchronous middleware\n\ni.e. the function is executed and the next middleware function in queue will be called immediately.\n\n```js\nfunction () { //no callbacks\n\t//synchronous execution\n}\n```\n\n#### serially (a)synchronous middleware\n\ni.e. the next middleware function in queue will be called once the current middleware function finishes its (asynchronous) execution.\n\n```js\nfunction (next) { //a single callback\n\t//asynchronous execution, i.e. further execution is halted until `next` is called.\n\tsetTimeout(next, 1000);\n}\n```\n\n#### parallel (a)synchronous middleware\n\ni.e. the next middleware function in queue will be called once the current middleware function signals it, however the whole queue will only be finished once the current middleware function has completed its (a)synchronous execution.\n\n```js\nfunction (next, done) { //two callbacks\n\t//asynchronous execution, i.e. further execution is halted until `next` is called.\n\tsetTimeout(next, 500);\n\t//full middleware queue handling is halted until `done` is called.\n\tsetTimeout(done, 1000);\n}\n```\n\n#### thenable middleware (promises)\n\ni.e. the next middleware function in queue will be called once the [thenable][thenable] middleware function has resolved its promise.\n\n```js\nfunction () { //no callbacks\n\t//create promise, i.e. further execution is halted until the promise is resolved.\n\treturn promise\n}\n```\n\n(Sidenote: all consumer-facing methods exist out of a single word)\n\nSee:\n\n* [GrapplingHook#pre][GrapplingHook#pre] on how to register [middleware][middleware] functions to `pre` hooks.\n* [GrapplingHook#post][GrapplingHook#post] on how to register [middleware][middleware] functions to `post` hooks.\n* [GrapplingHook#hook][GrapplingHook#hook] on how to register [middleware][middleware] functions to `pre` or `post` hooks.\n\nAll three allow you to register middleware functions by either passing them as parameters to the method:\n\n```js\ninstance.pre('save', notifyUser, checkPermissions, doSomethingElseVeryImportant);\n```\n\nOr (if the grappling-hook instances are [setup for thenables][setup-thenables]) by chaining them with `then`:\n\n```js\ninstance.pre('save')\n\t.then(notifyUser)\n\t.then(checkPermissions)\n\t.then(doSomethingElseVeryImportant)\n```\n\nAdditionally see:\n\n* [GrapplingHook#unhook][GrapplingHook#unhook] on how to deregister [middleware][middleware] functions from hooks.\n* [GrapplingHook#hookable][GrapplingHook#hookable] on how to check whether a hook is available.\n\n### Producer-facing API\n\n`grappling-hook` provides you with methods to store, retrieve and reuse presets.\n\n* [grappling-hook.set][grappling-hook.set] on how to store presets.\n* [grappling-hook.get][grappling-hook.get] on how to view presets.\n\nAll `grappling-hook` factory functions allow you to reuse presets, see [presets example](#presets).\n\nSee:\n\n* [grappling-hook.create][grappling-hook.create] on how to create vanilla `GrapplingHook` objects.\n* [grappling-hook.mixin][grappling-hook.mixin] on how to add `GrapplingHook` functionality to existing objects.\n* [grappling-hook.attach][grappling-hook.attach] on how to add `GrapplingHook` functionality to constructors.\n\nBy default `GrapplingHook` hooks need to be either explicitly declared with [GrapplingHook#allowHooks][GrapplingHook#allowHooks] if you want to call your hooks directly or by wrapping existing methods.\n\n`GrapplingHook` objects can have 3 kinds of hooks:\n\n#### Asynchronous hooks\n\nAsynchronous hooks **require** a callback as the final parameter. It will be called once all pre _and_ post middleware has finished. When using a wrapped method, the original (unwrapped) method will be called in between the pre and post middleware.\n\nAsynchronous hooks _always_ finish asynchronously, i.e. even if only synchronous middleware has been registered to a hook `callback` will always be called asynchronously (next tick at the earliest).\n\nMiddleware added to asynchronous hooks can be synchronous, serially asynchronous, parallel asynchronous or thenable. See [middleware][middleware] for more information.\n\nSee:\n\n* [GrapplingHook#addHooks][GrapplingHook#addHooks] or its alias [GrapplingHook#addAsyncHooks][GrapplingHook#addAsyncHooks] on how to wrap asynchronous methods with pre/post hooks.\n* [GrapplingHook#callHook][GrapplingHook#callHook] or its alias [GrapplingHook#callAsyncHook][GrapplingHook#callAsyncHook] on how to call an asynchronous pre or post hook directly.\n\n#### Synchronous hooks\n\nSynchronous hooks do not require a callback and allow the possibility to return values from wrapped methods.\n\nThey _always_ finish synchronously, which means consumers are not allowed to register any asynchronous middleware (including thenables) to synchronous hooks.\n\nSee:\n\n* [GrapplingHook#addSyncHooks][GrapplingHook#addSyncHooks] on how to wrap synchronous methods with pre/post hooks.\n* [GrapplingHook#callSyncHook][GrapplingHook#callSyncHook] on how to call a synchronous pre or post hook directly.\n\n#### Thenable hooks\n\nThenable hooks **must** return a promise.\n\nThey _always_ finish asynchronously, i.e. even if only synchronous middleware has been registered to a thenable hook the promise will be resolved asynchronously.\n\nMiddleware added to thenable hooks can be synchronous, serially asynchronous, parallel asynchronous or thenable. See [middleware][middleware] for more information.\n\nSee:\n\n* [GrapplingHook#addThenableHooks][GrapplingHook#addThenableHooks] on how to wrap thenable methods with pre/post hooks.\n* [GrapplingHook#callThenableHook][GrapplingHook#callThenableHook] on how to call a thenable pre or post hook directly.\n\nIn order to create thenable hooks `grappling-hook` must be properly [setup for creating thenables][setup-thenables].\n\n\n### Introspection\n\nYou can check if a hook has middleware registered with [GrapplingHook#hasMiddleware][GrapplingHook#hasMiddleware] or you can even access the raw middleware functions through [GrapplingHook#getMiddleware][GrapplingHook#getMiddleware].\n\n## Examples\n\n### mix middleware types\n\nYou can **mix sync/async serial/parallel and thenable middleware** any way you choose (for aynchronous and thenable hooks):\n\n```js\ninstance.pre('save', function (next) {\n\t//async serial\n\tconsole.log('async serial: setup');\n\tsetTimeout(function () {\n\t\tconsole.log('async serial: done');\n\t\tnext();\n\t}, 100);\n}, function () {\n\t//sync\n\tconsole.log('sync: done');\n}, function (next, done) {\n\t//async parallel\n\tconsole.log('async parallel: setup');\n\tsetTimeout(function () {\n\t\tconsole.log('async parallel: done');\n\t\tdone();\n\t}, 200);\n\tnext();\n}, function () {\n\t//thenable\n\tconsole.log('thenable: setup');\n\tvar done;\n\tvar promise = new P(function (resolve, fail) {\n\t\tdone = resolve;\n\t});\n\tsetTimeout(function () {\n\t\tconsole.log('thenable: done');\n\t\tdone();\n\t}, 30);\n\treturn promise;\n});\n```\n```sh\n# output\nasync serial: setup\nasync serial: done\nsync: done\nasync parallel: setup\nthenable: setup\nthenable: done\nasync parallel: done\n```\n\n### Creating a `GrapplingHook` object\n\nYou can easily add methods to a new `grappling-hook` instance which are automatically ready for hooking up middleware:\n\n```js\nvar grappling = require('grappling-hook');\n\n// create an instance\nvar instance = grappling.create();\n\n// declare the hookable methods\ninstance.addHooks({\n\tsave: function (done) {\n\t\tconsole.log('save!');\n\t\tdone();\n\t}\n});\n\n//allow middleware to be registered for a hook\ninstance.pre('save', function () {\n\tconsole.log('saving!');\n}).post('save', function () {\n\tconsole.log('saved!');\n});\n\ninstance.save(function (err) {\n\tconsole.log('All done!!');\n});\n```\n```sh\n# output:\nsaving!\nsave!\nsaved!\nAll done!!\n```\n\n### Using an existing object\n\nYou can choose to enable hooking for an already existing object with methods:\n\n```js\nvar grappling = require('grappling-hook');\n\nvar instance = {\n\tsave: function (done) {\n\t\tconsole.log('save!');\n\t\tdone();\n\t}\n};\n\ngrappling.mixin(instance); // add grappling-hook functionality to an existing object\n\ninstance.addHooks('save'); // setup hooking for an existing method\n\ninstance.pre('save', function () {\n\tconsole.log('saving!');\n}).post('save', function () {\n\tconsole.log('saved!');\n});\n\ninstance.save(function (err) {\n\tconsole.log('All done!!');\n});\n\n```\n```sh\n# output:\nsaving!\nsave!\nsaved!\nAll done!!\n```\n\n### Using a 'class'\n\nYou can patch a `prototype` with `grappling-hook` methods:\n\n```js\nvar grappling = require('grappling-hook');\n\nvar MyClass = function () {};\n\nMyClass.prototype.save = function (done) {\n\tconsole.log('save!');\n\tdone();\n};\n\ngrappling.attach(MyClass); // attach grappling-hook functionality to a 'class'\n\nvar instance = new MyClass();\ninstance.addHooks('save'); // setup hooking for an existing method\n\ninstance.pre('save', function () {\n\tconsole.log('saving!');\n}).post('save', function () {\n\tconsole.log('saved!');\n});\n\ninstance.save(function (err) {\n\tconsole.log('All done!!');\n});\n```\n```sh\n# output:\nsaving!\nsave!\nsaved!\nAll done!!\n```\n\n### Adding hooks to synchronous methods\n\n`addSyncHooks` allows you to register methods for enforced synchronized middleware execution:\n\n```js\nvar grappling = require('grappling-hook');\n\nvar instance = {\n\tsaveSync: function (filename) {\n\t\tfilename = Date.now() + '-' + filename;\n\t\tconsole.log('save', filename);\n\t\treturn filename;\n\t}\n};\n\ngrappling.mixin(instance); // add grappling-hook functionality to an existing object\n\ninstance.addSyncHooks('saveSync'); // setup hooking for an existing (sync) method\n\ninstance.pre('saveSync', function () {\n\tconsole.log('saving!');\n}).post('saveSync', function () {\n\tconsole.log('saved!');\n});\n\nvar newName = instance.saveSync('example.txt');\nconsole.log('new name:', newName);\n```\n```sh\n# output:\nsaving!\nsave 1431264587725-example.txt\nsaved!\nnew name: 1431264587725-example.txt\n```\n\n### Passing parameters\n\nYou can pass any number of parameters to your middleware:\n\n```js\ninstance.pre('save', function (foo, bar) {\n\tconsole.log('saving!', foo, bar);\n});\n\ninstance.callHook('pre:save', 'foo', { bar: 'bar'}, function () {\n\tconsole.log('done!');\n});\n```\n```sh\n# output:\nsaving! foo { bar: 'bar' }\ndone!\n```\n\n```js\ninstance.save = function (filename, dir, done) {\n\t// do your magic\n\tdone();\n}\n\ninstance.pre('save', function (filename, dir) {\n\tconsole.log('saving!', filename, dir);\n});\n\ninstance.save('README.md', 'docs');\n```\n```sh\n# output:\nsaving! README.md docs\n```\n\n### Contexts\n\nBy default all middleware is called with the `GrapplingHook` instance as an execution context, e.g.:\n\n```js\ninstance.pre('save', function () {\n\tconsole.log(this);\n});\n\ninstance.toString = function () {\n\treturn \"That's me!!\";\n};\ninstance.callSyncHook('pre:save');\n```\n```sh\n# output:\nThat's me!!\n```\n\nHowever, `callHook`, `callSyncHook` and `callThenableHook` accept a `context` parameter to change the scope:\n\n```js\ninstance.pre('save', function () {\n\tconsole.log(this);\n});\n\ninstance.toString = function () {\n\treturn \"That's me!!\";\n};\n\nvar context = {\n\ttoString: function () {\n\t\treturn 'Different context!';\n\t}\n};\ninstance.callSyncHook(context, 'pre:save'); // the `context` goes first\n```\n```sh\n# output:\nDifferent context!\nAll done!!\n```\n\n### Lenient mode\n\nBy default `grappling-hook` throws errors if you try to add middleware to or call a non-existing hook. However if you want to allow more leeway (for instance for dynamic delegated hook registration) you can turn on lenient mode:\n\n```js\nvar instance = grappling.create({\n\tstrict: false\n});\n```\n\n### Other qualifiers\n\nBy default `grappling-hook` registers `pre` and `post` methods, but you can configure other names if you want:\n\n```js\nvar instance = grappling.create({\n\tqualifiers: {\n\t\tpre: 'before',\n\t\tpost: 'after'\n\t}\n});\n\n//now use `before` and `after` instead of `pre` and `post`:\n\ninstance.addHooks('save');\ninstance.before('save', fn);\ninstance.after('save', fn);\ninstance.save();\n```\n\nThere's one caveat: you _have_ to configure both or none.\n\n### Setting up thenable hooks\n\nIf you want to use thenable hooks, you'll need to provide `grappling-hook` with a thenable factory function, since it's promise library agnostic (i.e. you can use it with any promise library you want).\n\nJust to be clear: you do NOT need to provide a thenable factory function in order to allow thenable middleware, this works out of the box.\n\n```js\nvar P = require('bluebird');\n\nvar instance = grappling.create({\n\tcreateThenable: function (fn) {\n\t\treturn new P(fn);\n\t}\n})\n\ninstance.addThenableHooks({\n\tsave: function (filename) {\n\t\tvar p = new P(function (resolve, reject) {\n\t\t\t// add code for saving\n\t\t});\n\t\treturn p;\n\t}\n});\n\ninstance.save('examples.txt').then(function () {\n\tconsole.log('Finished!');\n});\n```\n\n### Error handling\n\n- Errors thrown in middleware registered to synchronized hooks will bubble through\n\n\t```js\n\tinstance.pre('save', function () {\n\t\tthrow new Error('Oh noes!');\n\t});\n\tinstance.callSyncHook('pre:save');\n\t```\n\t```sh\n\t# output:\n\tError: Oh noes!\n\t```\n\n- Errors thrown in middleware registered to asynchronous hooks are available as the `err` object in the `callback`.\n\n\t```js\n\tinstance.pre('save', function () {\n\t\tthrow new Error('Oh noes!');\n\t});\n\tinstance.callHook('pre:save', function (err) {\n\t\tconsole.log('Error occurred:', err);\n\t});\n\t```\n\t```sh\n\t# output:\n\tError occurred: Error: Oh noes!\n\t```\n\n- Errors thrown in middleware registered to thenable hooks trigger the promise's rejectedHandler.\n\n\t```js\n\tinstance.pre('save', function () {\n\t\tthrow new Error('Oh noes!');\n\t});\n\tinstance.callThenableHook('pre:save').then(null, function (err) {\n\t\tconsole.log('Error occurred:', err);\n\t});\n\t```\n\t```sh\n\t# output:\n\tError occurred: Error: Oh noes!\n\t```\n\n- Async middleware can pass errors to their `next` (serial or parallel) or `done` (parallel only) callbacks, which will be passed as the `err` object parameter for asynchronous hooks:\n\n\t```js\n\t//async serial\n\tinstance.pre('save', function (next) {\n\t\tnext(new Error('Oh noes!'));\n\t});\n\t```\n\t```js\n\t//async parallel\n\tinstance.pre('save', function (next, done) {\n\t\tnext();\n\t\tdone(new Error('Oh noes!'));\n\t});\n\t```\n\t```js\n\tinstance.callHook('pre:save', function (err) {\n\t\tif (err) {\n\t\t\tconsole.log('An error occurred:', err);\n\t\t}\n\t});\n\t```\n\t```sh\n\t# output for both:\n\tAn error occurred: Oh noes!\n\t```\n- Async middleware can pass errors to their `next` (serial or parallel) or `done` (parallel only) callbacks, which will trigger the rejectedHandler of thenable hooks:\n\n\t```js\n\t//async serial\n\tinstance.pre('save', function (next) {\n\t\tnext(new Error('Oh noes!'));\n\t});\n\t```\n\t```js\n\t//async parallel\n\tinstance.pre('save', function (next, done) {\n\t\tnext();\n\t\tdone(new Error('Oh noes!'));\n\t});\n\t```\n\t```js\n\tinstance.callThenableHook('pre:save').then(null, function (err) {\n\t\tif (err) {\n\t\t\tconsole.log('An error occurred:', err);\n\t\t}\n\t});\n\t```\n\t```sh\n\t# output for both:\n\tAn error occurred: Oh noes!\n\t```\n\n- Thenable middleware can reject their promises, which will be passed as the `err` object parameter for asynchronous hooks:\n\n\t```js\n\tinstance.pre('save', function (next) {\n\t\tvar p = new Promise(function (succeed, fail) {\n\t\t\tfail('Oh noes!');\n\t\t});\n\t\treturn p;\n\t});\n\t```\n\t```js\n\tinstance.callHook('pre:save', function (err) {\n\t\tif (err) {\n\t\t\tconsole.log('An error occurred:', err);\n\t\t}\n\t});\n\t```\n\t```sh\n\t# output:\n\tAn error occurred: Oh noes!\n\t```\n- Thenable middleware can reject their promises, which will trigger the rejectedHandler of thenable hooks:\n\n\t```js\n\tinstance.pre('save', function (next) {\n\t\tvar p = new Promise(function (succeed, fail) {\n\t\t\tfail('Oh noes!');\n\t\t});\n\t\treturn p;\n\t});\n\t```\n\t```js\n\tinstance.callThenableHook('pre:save').then(null, function (err) {\n\t\tif (err) {\n\t\t\tconsole.log('An error occurred:', err);\n\t\t}\n\t});\n\t```\n\t```sh\n\t# output for both:\n\tAn error occurred: Oh noes!\n\t```\n\n### Presets\n\nYou can [set][grappling-hook.set] and use preset configurations, in order to reuse them in your project.\n\n```js\nvar presets = {\n\tstrict: false,\n\tqualifiers: {\n\t\tpre: 'before',\n\t\tpost: 'after'\n\t}\n};\nvar grappling = require('grappling-hook');\ngrappling.set('grappling-hook:examples.presets', presets);\n\n//all grappling-hook factory methods accept a presetname:\nvar instance = grappling.create('grappling-hook:examples.presets');\n\ninstance.addSyncHooks({\n\tsave: function () {\n\t\tconsole.log('Saving!');\n\t}\n});\n\ninstance.before('save', function () {\n\tconsole.log('Before save!');\n}).after('save', function () {\n\tconsole.log('After save!');\n}).save();\n```\n```sh\n# output:\nBefore save!\nSaving!\nAfter save!\n```\n\nIf you want to override preset configuration options, just pass them to the factory function, as always:\n\n```js\nvar instance = grappling.create('grappling-hook:examples.presets', {\n\tstrict: true\n});\n\n/*\ninstance has the following configuration:\n{\n\tstrict: true,\n\tqualifiers: {\n\t\tpre: 'before',\n\t\tpost: 'after'\n\t}\n}\n*/\n```\n\nWith [grappling-hook.get][grappling-hook.get] you can introspect the configuration options of a preset:\n\n```js\nconsole.log(grappling.get('grappling-hook:examples.presets'));\n```\n```sh\n# output:\n{\n\tstrict: false,\n\tqualifiers: {\n\t\tpre: 'before',\n\t\tpost: 'after'\n\t}\n}\n```\n\n[middleware]: https://keystonejs.github.io/grappling-hook/global.html#middleware\n[thenable]: https://keystonejs.github.io/grappling-hook/global.html#thenable\n[grappling-hook.get]: https://keystonejs.github.io/grappling-hook/module-grappling-hook.html#.get\n[grappling-hook.set]: https://keystonejs.github.io/grappling-hook/module-grappling-hook.html#.set\n[grappling-hook.create]: https://keystonejs.github.io/grappling-hook/module-grappling-hook.html#.create\n[grappling-hook.mixin]: https://keystonejs.github.io/grappling-hook/module-grappling-hook.html#.mixin\n[grappling-hook.attach]: https://keystonejs.github.io/grappling-hook/module-grappling-hook.html#.attach\n[GrapplingHook#pre]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#pre\n[GrapplingHook#post]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#post\n[GrapplingHook#hook]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#hook\n[GrapplingHook#unhook]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#unhook\n[GrapplingHook#hookable]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#hookable\n[GrapplingHook#allowHooks]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#allowHooks\n[GrapplingHook#addHooks]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#addHooks\n[GrapplingHook#addAsyncHooks]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#addAsyncHooks\n[GrapplingHook#addSyncHooks]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#addSyncHooks\n[GrapplingHook#addThenableHooks]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#addThenableHooks\n[GrapplingHook#callHook]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#callHook\n[GrapplingHook#callAsyncHook]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#callAsyncHook\n[GrapplingHook#callSyncHook]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#callSyncHook\n[GrapplingHook#callThenableHook]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#callThenableHook\n[GrapplingHook#hasMiddleware]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#hasMiddleware\n[GrapplingHook#getMiddleware]: https://keystonejs.github.io/grappling-hook/GrapplingHook.html#getMiddleware\n\n[other-qualifiers]: #other-qualifiers\n[synchronous-hooks]: #synchronous-hooks\n[setup-thenables]: #setting-up-thenable-hooks\n[thenable-middleware]: #thenable-middleware-promises\n[thenable-hooks]: #thenable-hooks\n\n## Changelog\n\nSee [History.md](https://github.com/keystonejs/grappling-hook/blob/master/History.md)\n\n## Contributing\n\nPull requests welcome. Make sure you use the .editorconfig in your IDE of choice and please adhere to the coding style as defined in .eslintrc.\n\n* `npm test` for running the tests\n* `npm run lint` for running eslint\n* `npm run test-cov` for churning out test coverage. (We go for 100% here!)\n* `npm run docs` for generating the API docs\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/keystonejs/grappling-hook.git"
  },
  "scripts": {
    "coveralls": "npm run test-cov;cat ./coverage/lcov.info | coveralls",
    "docs": "jsdoc -c jsdoc.json -R README.md",
    "gh-pages": "grunt gh-pages",
    "lint": "eslint index.js tests",
    "test": "mocha tests",
    "test-cov": "istanbul cover _mocha tests",
    "travis": "npm run lint && npm test"
  },
  "version": "3.0.0"
}
