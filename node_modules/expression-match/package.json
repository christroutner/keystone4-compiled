{
  "_args": [
    [
      {
        "raw": "expression-match@0.0.17",
        "scope": null,
        "escapedName": "expression-match",
        "name": "expression-match",
        "rawSpec": "0.0.17",
        "spec": "0.0.17",
        "type": "version"
      },
      "/home/connextcms/test/node_modules/keystone"
    ]
  ],
  "_from": "expression-match@0.0.17",
  "_id": "expression-match@0.0.17",
  "_inCache": true,
  "_location": "/expression-match",
  "_nodeVersion": "4.2.2",
  "_npmOperationalInternal": {
    "host": "packages-16-east.internal.npmjs.com",
    "tmp": "tmp/expression-match-0.0.17.tgz_1460950855879_0.9252266122493893"
  },
  "_npmUser": {
    "name": "inquisive",
    "email": "inquisiveq@gmail.com"
  },
  "_npmVersion": "2.14.7",
  "_phantomChildren": {},
  "_requested": {
    "raw": "expression-match@0.0.17",
    "scope": null,
    "escapedName": "expression-match",
    "name": "expression-match",
    "rawSpec": "0.0.17",
    "spec": "0.0.17",
    "type": "version"
  },
  "_requiredBy": [
    "/keystone"
  ],
  "_resolved": "https://registry.npmjs.org/expression-match/-/expression-match-0.0.17.tgz",
  "_shasum": "1f8cb7e10e937ae40090831ad46ed8e6d1b3cf45",
  "_shrinkwrap": null,
  "_spec": "expression-match@0.0.17",
  "_where": "/home/connextcms/test/node_modules/keystone",
  "author": {
    "name": "inquisive"
  },
  "bugs": {
    "url": "https://github.com/inquisive/expression-match/issues"
  },
  "dependencies": {
    "lodash": "4.11.1"
  },
  "description": "expression comparison",
  "devDependencies": {
    "must": "^0.13.1"
  },
  "directories": {},
  "dist": {
    "shasum": "1f8cb7e10e937ae40090831ad46ed8e6d1b3cf45",
    "tarball": "https://registry.npmjs.org/expression-match/-/expression-match-0.0.17.tgz"
  },
  "engines": {
    "node": ">=0.10.22",
    "npm": ">=1.3.14"
  },
  "gitHead": "c8287106b1ea3c8bac5a951ea3314099036554fb",
  "homepage": "https://github.com/inquisive/expression-match#readme",
  "keywords": [
    "expression",
    "comparison"
  ],
  "license": "MIT",
  "main": "./ExMatch.js",
  "maintainers": [
    {
      "name": "inquisive",
      "email": "inquisiveq@gmail.com"
    }
  ],
  "name": "expression-match",
  "optionalDependencies": {},
  "private": false,
  "readme": "# Match Objects with Expressions\n### Use expression patterns to compare object values\n\n**Table of Contents**\n\n- [ExMatch.js](#expression-matcher)\n\t- [Installation](#installation)\n\t- [Expressions](#expressions)\n\t- [Configuration](#configuration)\n\t- [Methods](#add-patterns)\n\t\t- [Add Patterns](#add-patterns)\n\t\t- [Match](#match)\n\t\t- [Single Expression Match](#select-expression-match)\n\t\t- [Custom Selector and Comparer](#custom-selector-and-comparer)\t\n\t- [Usage](#usage)\n\t\t- [Keystone dependsOn](#keystone-dependson)\n\t\t- [Examples](#examples)\n\t- [Testing](#testing)\n\t- [History](https://github.com/inquisive/expression-match/blob/master/HISTORY.md) \n\t- [License](#license)\n\n\n### Installation\n```\nnpm install expression-match\n```\n### Expressions\n  * add\n  * any\n  * eq\n  * gt\n  * gte\n  * in\n  * lt\n  * lte\n  * ne\n  * not\n  * or\n  * regex\n\n### Configuration\n```javascript\nvar ExMatch = require('expression-match');\n\nvar searchFields = {\n\tstr1: 'string',\n\tstr2: 'hello',\n\tstr3: 'plug',\n\tstr4: ['1','2'],\n\tnum1: 1,\n\tnum2: '2',\n\tnum3: '3',\n\tcheck1:'true',\n\tcheck2: false,\n\tcheck3: undefined,\n\tcheck4: 0,\n\tcheck5: true,\n\tcheck6: 'false'\n}\nvar patterns = {\n\t// true\n\te1: { $or:[ { str1:['first','third'] } , {check1: 'true'} ] },\n\te2: { $gt: { num3:1 }, $and:[{num1:'1'}, {str3: { or: ['cork','clog','plug'] } }, {num2:{$lt:4}}] },\n\te3: { str2: ['hi', 'hello'], str3: { $regex: 'plu.*/i' } },\n\te4: { num3: { $lte: 3 } },\n\te5: { str1: [{ or: 'strings' }, { or: 'string'}] },\n}\n\n/* debug can be any truthy or 2 for compare only\n * @param {object} matchPatterns\n * @param {object} matchAgainst\n * @param {object/boolean} options - debug only when boolean \n * */\n \n// `options.expression` changes the default expression which is `$and`.  \nvar Match = new ExMatch( patterns.e2, searchFields, { debug: true, expression: '$and' });  \n\n// debig messages only.  \nvar Match = new ExMatch( patterns.e3, searchFields, true);\n```\n\n### Add Patterns\nEach method returns `this` for chainability\n```javascript\nMatch.\n\taddSearchParams( patterns.e3 ).\n\tand( patterns.e1 ).\n\tany( patterns.e3 ).\n\teq( { num1: 2, str2: 'hello' } )\n\tgt( [ { num1: 2 } ] ).\n\tgte( [ { num1: 2 }, { num2: 5 } ] ).\n\tin( { num1: ['2', '1'] } )\n\tlt( { num1: 2 } ).\n\tlte( { num1: 2 } ).\n\tne( { num1: 2 } ).\n\tnot( { str1: 'test' } ).\n\tregex( { str1: 'fir.*/i' } );\n\n```\n\n### Match\nRun all expression searches in the queue\n```\nMatch.match()\n```\n\n### Select Expression Match\nRun a single Expression search from the queue\n```javascript\n\nMatch.regex({str2: { $regex: 'hel.*/i'}});\nvar ret = Match.$regex();\n\n/* All return boolean true/false */\nMatch.$and();\nMatch.$any(); \nMatch.$eq();\nMatch.$gt();\nMatch.$gte();\nMatch.$in();\nMatch.$lt();\nMatch.$lte();\nMatch.$ne();\nMatch.$not();\nMatch.$or();\nMatch.$regex();\n\n```\n\n### Custom Selector and Comparer\nin progress\n\n###Usage\n\n### Keystone dependsOn\n```\nvar Tester = new keystone.List('Tester');\n\nvar patterns = {\n\tearth: { $and:[ {str1:'earth'} , {check2:true} ] },\n\tand: { $lte:[ {num1:1} , {num3:4} ] },\n\tice: { $gt:[{num3:1}],$and:[{num1:'1'},{sel1:['first','third']},{num2:{$lt:4}}] },\n\twater: { $or:[ {num1:{$gte:6}} , {num2:{$lte:4}} ] },\n\tfire: { sel1:'second',str3: {$regex: 'fir.*/i'} }\n}\n\nTester.add({\n}, 'Depends On', {\n\tisIce: { type: Boolean, label: 'Ice', dependsOn: patterns.ice},\n\tisFire: { type: Boolean, label: 'Fire' ,dependsOn: patterns.fire},\n\tisEarth: { type: Boolean, label: 'Earth', dependsOn: patterns.earth},\n\tisWater: { type: Boolean, label: 'Water', dependsOn: patterns.water},\n\tisAnd: { type: Boolean, label: 'And', dependsOn: patterns.and }\n\n}, 'Show Dependants When', {\n\n    sel1: { type: Types.Select, many: true, emptyOption: true },\n\tcheck1: { type: Boolean,  label: 'Check 1' , note:'earth ' },\n\tcheck2: { type: Boolean,  label: 'Check 2'  },\n\tnum1: {type: Types.Number, note:'show `Water` when >= `6`  -- --  `<=1` == `And` with num3'  },\n\tnum2: {type: Types.Number, note:'show `Water` when <= `4`'},\n\tnum3: {type: Types.Number, note: '`<=4` show `And` with num1'  },\n\tstr1: {type:String, note:'type earth with check2 to show `Earth`'},\n\tstr2: String,\n\tstr3: {type:String, note:'regex `fir*`  with `sel1`==`second` to show `Fire`'},\n});\n\nTester.register();\n\n```\n### Examples\n```\nvar ExMatch = require('exmatch');\n\n// Create a searchfield:value object and some test search objects\n\tsearchFields = {\n\t\tstr1: 'string',  str2: 'hello',  str3: 'plug',\n\t\tnum1: 1,  num2: '2',  num3: '3', \n        check1:'true',  check2: false\n\t}\n\t\n    var Match = new ExMatch({\n    \t$or:[ {str1:['string1']}, {check1:'true'} ],\n        num2:'2',\n        num1:{ $lt:2 }\n    },searchFields);\n    var ret = Match.match();\n    ==> true\n    \n    var m7 = new ExMatch({}, searchFields, 2);  //dubug on for compare only\n\tm7.\n    \tand({check2:false}).\n\t\tany({check1:false}).\n\t\tany({ str2: { $regex: 'hel.*/i'} });\n\tvar ret = m7.match();\n\t==> true\n    \n    var Match = new ExMatch({ num2:{$eq:2} , $eq:{num3:'3'}, $eq:[{num1:'1'}] }, searchFields);\n    var ret = Match.match();\n    ==> false\n    \n    var Match = new ExMatch({ num2:{$eq:2} ,$eq:{num2:2}, $eq:[{num2:1}] } , searchFields);\n    var ret = Match.match();\n    ==> false\n    \n    var regex = new ExMatch({}, searchFields, true); //dubug on\n\tregex.regex({str2: { $regex: 'hel.*/i'}});\n\tvar ret = regex.$regex();\n\t==> true\n   \n\n```\n\n### Testing\nTest file located in `test` dir\n```\nnpm i -g mocha\n\nnpm test\n\n```\n\n\n### License\nMIT License\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/inquisive/expression-match.git"
  },
  "scripts": {
    "test": "mocha ./test/ExMatch.js"
  },
  "version": "0.0.17"
}
