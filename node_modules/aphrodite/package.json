{
  "_args": [
    [
      {
        "raw": "aphrodite@1.1.0",
        "scope": null,
        "escapedName": "aphrodite",
        "name": "aphrodite",
        "rawSpec": "1.1.0",
        "spec": "1.1.0",
        "type": "version"
      },
      "/home/connextcms/test/node_modules/keystone"
    ]
  ],
  "_from": "aphrodite@1.1.0",
  "_id": "aphrodite@1.1.0",
  "_inCache": true,
  "_location": "/aphrodite",
  "_nodeVersion": "4.4.1",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/aphrodite-1.1.0.tgz_1478564537058_0.22998191672377288"
  },
  "_npmUser": {
    "name": "xymostech",
    "email": "xymostech@gmail.com"
  },
  "_npmVersion": "2.14.20",
  "_phantomChildren": {},
  "_requested": {
    "raw": "aphrodite@1.1.0",
    "scope": null,
    "escapedName": "aphrodite",
    "name": "aphrodite",
    "rawSpec": "1.1.0",
    "spec": "1.1.0",
    "type": "version"
  },
  "_requiredBy": [
    "/keystone"
  ],
  "_resolved": "https://registry.npmjs.org/aphrodite/-/aphrodite-1.1.0.tgz",
  "_shasum": "1da36afb9401adf13483e29aa7cae58ee0767605",
  "_shrinkwrap": null,
  "_spec": "aphrodite@1.1.0",
  "_where": "/home/connextcms/test/node_modules/keystone",
  "author": {
    "name": "Jamie Wong"
  },
  "bugs": {
    "url": "https://github.com/Khan/aphrodite/issues"
  },
  "dependencies": {
    "asap": "^2.0.3",
    "inline-style-prefixer": "^2.0.0"
  },
  "description": "Inline styles in JS that just work (TM)",
  "devDependencies": {
    "babel": "^5.8.23",
    "babel-core": "^5.8.25",
    "babel-loader": "^5.3.2",
    "chai": "^3.3.0",
    "eslint": "^3.7.1",
    "eslint-config-standard-react": "^4.2.0",
    "eslint-plugin-react": "^6.3.0",
    "jsdom": "^6.5.1",
    "mocha": "^2.3.3",
    "npm-run-all": "^1.7.0",
    "nyc": "^6.4.4",
    "rimraf": "^2.5.2",
    "webpack": "^1.12.2"
  },
  "directories": {},
  "dist": {
    "shasum": "1da36afb9401adf13483e29aa7cae58ee0767605",
    "tarball": "https://registry.npmjs.org/aphrodite/-/aphrodite-1.1.0.tgz"
  },
  "gitHead": "0ea47fcd05f18af851f0a77c54bf9db8b6b538df",
  "homepage": "https://github.com/Khan/aphrodite",
  "keywords": [
    "css",
    "react",
    "inline-styles"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "jlfwong",
      "email": "jamie.lf.wong@gmail.com"
    },
    {
      "name": "xymostech",
      "email": "xymostech@gmail.com"
    }
  ],
  "name": "aphrodite",
  "optionalDependencies": {},
  "readme": "# Aphrodite: Inline Styles that work\n\n[![npm version](https://badge.fury.io/js/aphrodite.svg)](https://badge.fury.io/js/aphrodite) [![Build Status](https://travis-ci.org/Khan/aphrodite.svg?branch=master)](https://travis-ci.org/Khan/aphrodite) [![Gitter chat](https://img.shields.io/gitter/room/Khan/aphrodite.svg)](https://gitter.im/Khan/aphrodite)\n\nSupport for colocating your styles with your JavaScript component.\n\n- Works great with and without React\n- Supports media queries without window.matchMedia\n- Supports pseudo-selectors like `:hover`, `:active`, etc. without needing to\n  store hover or active state in components. `:visited` works just fine too.\n- Supports automatic global `@font-face` detection and insertion.\n- Respects precedence order when specifying multiple styles\n- Requires no AST transform\n- Injects only the exact styles needed for the render into the DOM.\n- Can be used for server rendering\n- Few dependencies, small (20k, 6k gzipped)\n- No external CSS file generated for inclusion\n- Autoprefixes styles\n\n# Installation\n\nAphrodite is distributed via [npm](https://www.npmjs.com/):\n\n```\nnpm install --save aphrodite\n```\n\n# API\n\nIf you'd rather watch introductory videos, you can find them [here](https://www.youtube.com/playlist?list=PLo4Zh55ZzNSBP78pCD0dZJi9zf8CA72_M).\n\n```jsx\nimport React, { Component } from 'react';\nimport { StyleSheet, css } from 'aphrodite';\n\nclass App extends Component {\n    render() {\n        return <div>\n            <span className={css(styles.red)}>\n                This is red.\n            </span>\n            <span className={css(styles.hover)}>\n                This turns red on hover.\n            </span>\n            <span className={css(styles.small)}>\n                This turns red when the browser is less than 600px width.\n            </span>\n            <span className={css(styles.red, styles.blue)}>\n                This is blue.\n            </span>\n            <span className={css(styles.blue, styles.small)}>\n                This is blue and turns red when the browser is less than\n                600px width.\n            </span>\n        </div>;\n    }\n}\n\nconst styles = StyleSheet.create({\n    red: {\n        backgroundColor: 'red'\n    },\n\n    blue: {\n        backgroundColor: 'blue'\n    },\n\n    hover: {\n        ':hover': {\n            backgroundColor: 'red'\n        }\n    },\n\n    small: {\n        '@media (max-width: 600px)': {\n            backgroundColor: 'red',\n        }\n    }\n});\n```\n\n## Conditionally Applying Styles\n\nNote: If you want to conditionally use styles, that is simply accomplished via:\n\n```jsx\nconst className = css(\n  shouldBeRed() ? styles.red : styles.blue,\n  shouldBeResponsive() && styles.small,\n  shouldBeHoverable() && styles.hover\n)\n\n<div className={className}>Hi</div>\n```\n\nThis is possible because any falsey arguments will be ignored.\n\n## Combining Styles\n\nTo combine styles, pass multiple styles or arrays of styles into `css()`. This is common when combining styles from an owner component:\n\n```jsx\nclass App extends Component {\n    render() {\n        return <Marker styles={[styles.large, styles.red]} />;\n    }\n}\n\nclass Marker extends Component {\n    render() {\n        // css() accepts styles, arrays of styles (including nested arrays),\n        // and falsy values including undefined.\n        return <div className={css(styles.marker, this.props.styles)} />;\n    }\n}\n\nconst styles = StyleSheet.create({\n    red: {\n        backgroundColor: 'red'\n    },\n\n    large: {\n        height: 20,\n        width: 20\n    },\n\n    marker: {\n        backgroundColor: 'blue'\n    }\n};\n```\n\n## Server-side rendering\n\nTo perform server-side rendering, make a call to `StyleSheetServer.renderStatic`, which takes a callback. Do your rendering inside of the callback and return the generated HTML. All of the calls to `css()` inside of the callback will be collected and the generated css as well as the generated HTML will be returned.\n\nTo perform rehydration, call `StyleSheet.rehydrate` with the list of generated class names returned to you by `StyleSheetServer.renderStatic`.\n\nAs an example:\n\n```js\nimport { StyleSheetServer } from 'aphrodite';\n\n// Contains the generated html, as well as the generated css and some\n// rehydration data.\nvar {html, css} = StyleSheetServer.renderStatic(() => {\n    return ReactDOMServer.renderToString(<App/>);\n});\n\n// Return the base HTML, which contains your rendered HTML as well as a\n// simple rehydration script.\nreturn `\n    <html>\n        <head>\n            <style data-aphrodite>${css.content}</style>\n        </head>\n        <body>\n            <div id='root'>${html}</div>\n            <script src=\"./bundle.js\"></script>\n            <script>\n                StyleSheet.rehydrate(${JSON.stringify(css.renderedClassNames)});\n                ReactDOM.render(<App/>, document.getElementById('root'));\n            </script>\n        </body>\n    </html>\n`;\n```\n\n## Disabling `!important`\n\nBy default, Aphrodite will append `!important` to style definitions. This is\nintended to make integrating with a pre-existing codebase easier. If you'd like\nto avoid this behaviour, then instead of importing `aphrodite`, import\n`aphrodite/no-important`. Otherwise, usage is the same:\n\n```js\nimport { StyleSheet, css } from 'aphrodite/no-important';\n```\n\n## Font Faces\n\nCreating custom font faces is a special case. Typically you need to define a global `@font-face` rule. In the case of Aphrodite we only want to insert that rule if it's actually being referenced by a class that's in the page. We've made it so that the `fontFamily` property can accept a font-face object (either directly or inside an array). A global `@font-face` rule is then generated based on the font definition.\n\n```js\nconst coolFont = {\n    fontFamily: \"CoolFont\",\n    fontStyle: \"normal\",\n    fontWeight: \"normal\",\n    src: \"url('coolfont.woff2') format('woff2')\"\n};\n\nconst styles = StyleSheet.create({\n    headingText: {\n        fontFamily: coolFont,\n        fontSize: 20\n    },\n    bodyText: {\n        fontFamily: [coolFont, \"sans-serif\"]\n        fontSize: 12\n    }\n});\n```\n\nAphrodite will ensure that the global `@font-face` rule for this font is only inserted once, no matter how many times it's referenced.\n\n## Animations\n\nSimilar to [Font Faces](#font-faces), Aphrodite supports keyframe animations, but it's treated as a special case. Once we find an instance of the animation being referenced, a global `@keyframes` rule is created and appended to the page.\n\nAnimations are provided as objects describing the animation, in typical `@keyframes` fashion. Using the `animationName` property, you can supply a single animation object, or an array of animation objects. Other animation properties like `animationDuration` can be provided as strings.\n\n```js\nconst translateKeyframes = {\n    '0%': {\n        transform: 'translateX(0)',\n    },\n\n    '50%': {\n        transform: 'translateX(100px)',\n    },\n\n    '100%': {\n        transform: 'translateX(0)',\n    },\n};\n\nconst opacityKeyframes = {\n    'from': {\n        opacity: 0,\n    },\n\n    'to': {\n        opacity: 1,\n    }\n};\n\nconst styles = StyleSheet.create({\n    zippyHeader: {\n        animationName: [translateKeyframes, opacityKeyframes],\n        animationDuration: '3s, 1200ms',\n        animationIterationCount: 'infinite',\n    },\n});\n```\n\nAphrodite will ensure that `@keyframes` rules are never duplicated, no matter how many times a given rule is referenced.\n\n# Use without React\n\nAphrodite was built with React in mind, but does not depend on React. Here, you can see it\nused with [Web Components][webcomponents]:\n\n```js\nimport { StyleSheet, css } from 'aphrodite';\n\nconst styles = StyleSheet.create({\n    red: {\n        backgroundColor: 'red'\n    }\n});\n\nclass App extends HTMLElement {\n    attachedCallback() {\n        this.innerHTML = `\n            <div class=\"${css(styles.red)}\">\n                This is red.\n            </div>\n        `;\n    }\n}\n\ndocument.registerElement('my-app', App);\n```\n\n# Caveats\n\n## Style injection and buffering\n\nAphrodite will automatically attempt to create a `<style>` tag in the document's `<head>` element to put its generated styles in. Aphrodite will only generate one `<style>` tag and will add new styles to this over time. If you want to control which style tag Aphrodite uses, create a style tag yourself with the `data-aphrodite` attribute and Aphrodite will use that instead of creating one for you.\n\nTo speed up injection of styles, Aphrodite will automatically try to buffer writes to this `<style>` tag so that minimum number of DOM modifications happen.\n\nAphrodite uses [asap](https://github.com/kriskowal/asap) to schedule buffer flushing. If you measure DOM elements' dimensions in `componentDidMount` or `componentDidUpdate`, you can use `setTimeout` function to ensure all styles are injected.\n\n```js\nimport { StyleSheet, css } from 'aphrodite';\n\nclass Component extends React.Component {\n    render() {\n        return <div ref=\"root\" className={css(styles.div)} />;\n    }\n\n    componentDidMount() {\n        // At this point styles might not be injected yet.\n        this.refs.root.offsetHeight; // 0 or 10\n\n        setTimeout(() => {\n            this.refs.root.offsetHeight; // 10\n        }, 0);\n    }\n}\n\nconst styles = StyleSheet.create({\n    div: {\n        height: 10,\n    },\n});\n```\n\n## Assigning a string to a content property for a pseudo-element\n\nWhen assigning a string to the `content` property it requires double or single quotes in CSS.\nTherefore with Aphrodite you also have to provide the quotes within the value string for `content` to match how it will be represented in CSS.\n\nAs an example:\n\n```javascript\nconst styles = StyleSheet.create({\n  large: {\n      ':after': {\n        content: '\"Aphrodite\"',\n      },\n    },\n  },\n  small: {\n      ':before': {\n        content: \"'Aphrodite'\",\n      },\n    },\n  });\n```\nThe generated css will be:\n\n```css\n  .large_im3wl1:after {\n      content: \"Aphrodite\" !important;\n  }\n\n  .small_ffd5jf:before {\n      content: 'Aphrodite' !important;\n  }\n```\n\n## Overriding styles\n\nWhen combining multiple aphrodite styles, you are strongly recommended to merge all of your styles into a single call to `css()`, and should not combine the generated class names that aphrodite outputs (via string concatenation, `classnames`, etc.).\nFor example, if you have a base style of `foo` which you are trying to override with `bar`:\n\n### Do this:\n\n```js\nconst styles = StyleSheet.create({\n  foo: {\n    color: 'red'\n  },\n\n  bar: {\n    color: 'blue'\n  }\n});\n\n// ...\n\nconst className = css(styles.foo, styles.bar);\n```\n\n### Don't do this:\n\n```js\nconst styles = StyleSheet.create({\n  foo: {\n    color: 'red'\n  },\n\n  bar: {\n    color: 'blue'\n  }\n});\n\n// ...\n\nconst className = css(styles.foo) + \" \" + css(styles.bar);\n```\n\nWhy does it matter? Although the second one will produce a valid class name, it cannot guarantee that the `bar` styles will override the `foo` ones.\nThe way the CSS works, it is not the *class name that comes last on a element* that matters, it is specificity. When we look at the generated CSS though, we find that all of the class names have the same specificity, since they are all a single class name:\n\n```css\n.foo_im3wl1 {\n  color: red;\n}\n```\n\n```css\n.bar_hxfs3d {\n  color: blue;\n}\n```\n\nIn the case where the specificity is the same, what matters is *the order that the styles appear in the stylesheet*. That is, if the generated stylesheet looks like\n\n```css\n.foo_im3wl1 {\n  color: red;\n}\n.bar_hxfs3d {\n  color: blue;\n}\n```\n\nthen you will get the appropriate effect of the `bar` styles overriding the `foo` ones, but if the stylesheet looks like\n\n```css\n.bar_hxfs3d {\n  color: blue;\n}\n.foo_im3wl1 {\n  color: red;\n}\n```\n\nthen we end up with the opposite effect, with `foo` overriding `bar`! The way to solve this is to pass both of the styles into aphrodite's `css()` call. Then, it will produce a single class name, like `foo_im3wl1-o_O-bar_hxfs3d`, with the correctly overridden styles, thus solving the problem:\n\n```css\n.foo_im3wl1-o_O-bar_hxfs3d {\n  color: blue;\n}\n```\n\n## Advanced: Extensions\n\nExtra features can be added to Aphrodite using extensions.\n\nTo add extensions to Aphrodite, call `StyleSheet.extend` with the extensions\nyou are adding. The result will be an object containing the usual exports of\nAphrodite (`css`, `StyleSheet`, etc.) which will have your extensions included.\nFor example:\n\n```js\n// my-aphrodite.js\nimport {StyleSheet} from \"aphrodite\";\n\nexport default StyleSheet.extend([extension1, extension2]);\n\n// styled.js\nimport {StyleSheet, css} from \"my-aphrodite.js\";\n\nconst styles = StyleSheet.create({\n    ...\n});\n```\n\n**Note**: Using extensions may cause Aphrodite's styles to not work properly.\nPlain Aphrodite, when used properly, ensures that the correct styles will\nalways be applied to elements. Due to CSS specificity rules, extensions might\nallow you to generate styles that conflict with each other, causing incorrect\nstyles to be shown. See the global extension below to see what could go wrong.\n\n### Creating extensions\n\nCurrently, there is only one kind of extension available: selector handlers.\nThese kinds of extensions let you look at the selectors that someone specifies\nand generate new selectors based on them. They are used to handle pseudo-styles\nand media queries inside of Aphrodite. See the\n[`defaultSelectorHandlers` docs](src/generate.js?L8) for information about how\nto create a selector handler function.\n\nTo use your extension, create an object containing a key of the kind of\nextension that you created, and pass that into `StyleSheet.extend()`:\n\n```js\nconst mySelectorHandler = ...;\n\nconst myExtension = {selectorHandler: mySelectorHandler};\n\nStyleSheet.extend([myExtension]);\n```\n\nAs an example, you could write an extension which generates global styles like\n\n```js\nconst globalSelectorHandler = (selector, _, generateSubtreeStyles) => {\n    if (selector[0] !== \"*\") {\n        return null;\n    }\n\n    return generateSubtreeStyles(selector.slice(1));\n};\n\nconst globalExtension = {selectorHandler: globalSelectorHandler};\n```\n\nThis might cause problems when two places try to generate styles for the same\nglobal selector however! For example, after\n\n```js\nconst styles = StyleSheet.create({\n    globals: {\n        '*div': {\n            color: 'red',\n        },\n    }\n});\n\nconst styles2 = StyleSheet.create({\n    globals: {\n        '*div': {\n            color: 'blue',\n        },\n    },\n});\n\ncss(styles.globals);\ncss(styles2.globals);\n```\n\nIt isn't determinate whether divs will be red or blue.\n\n# Changelog\n\n## 1.1.0\n\n- Animations now support multiple animations per style ([see section on Animations](https://github.com/khan/aphrodite#animations)) ([PR #167](https://github.com/Khan/aphrodite/pull/167))\n\n## 1.0.0\n- Syntax extensions ([see section on Advanced extensions](https://github.com/Khan/aphrodite#advanced-extensions)) ([PR #95](https://github.com/Khan/aphrodite/pull/95))\n\n## 0.6.0\n- `css()` will now accept arbitrarily nested arrays. i.e. instead of `css(styles.a, styles.b)`, you can now do `css([styles.a, [styles.b, styles.c]])`. ([PR #154](https://github.com/Khan/aphrodite/pull/154))\n- Support for multiple font styles with the same font-family. ([PR #82](https://github.com/Khan/aphrodite/pull/82))\n\n# Tools\n\n- [Aphrodite output tool](https://output.jsbin.com/qoseye) - Paste what you pass to `StyleSheet.create` and see the generated CSS\n\n# TODO\n\n- Add Flow annotations\n- Add JSdoc\n- Consider removing !important from everything.\n\n# Other solutions\n\n- [js-next/react-style](https://github.com/js-next/react-style)\n- [dowjones/react-inline-style](https://github.com/dowjones/react-inline-style)\n- [martinandert/react-inline](https://github.com/martinandert/react-inline)\n\n# License (MIT)\n\nCopyright (c) 2016 Khan Academy\n\nIncludes works from https://github.com/garycourt/murmurhash-js, which is MIT licensed with the following copyright:\n\nCopyright (c) 2011 Gary Court\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n[webcomponents]: http://w3c.github.io/webcomponents/spec/custom\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Khan/aphrodite.git"
  },
  "scripts": {
    "build": "npm-run-all --parallel build:*",
    "build:commonjs": "webpack --output-library-target commonjs2 --output-filename aphrodite.js",
    "build:main": "babel -d lib/ src",
    "build:umd": "webpack --output-library-target umd --output-library aphrodite --output-filename aphrodite.umd.js --devtool source-map",
    "build:umdmin": "webpack --output-library-target umd --output-library aphrodite --output-filename aphrodite.umd.min.js -p --devtool source-map",
    "coverage": "nyc --check-coverage --lines 100 --branches 100 npm run tests",
    "lint": "eslint --fix --cache .",
    "posttest": "npm run lint",
    "prebuild": "rimraf dist lib",
    "preversion": "npm test",
    "test": "npm run coverage",
    "tests": "mocha --compilers js:babel/register tests",
    "tests:watch": "mocha --watch --compilers js:babel/register tests",
    "version": "npm run build && git add dist",
    "watch:build": "npm-run-all --parallel watch:build:*",
    "watch:build:commonjs": "npm run build:commonjs -- --watch",
    "watch:build:main": "npm run build:main -- --watch",
    "watch:build:umd": "npm run build:umd -- --watch",
    "watch:build:umdmin": "npm run build:umdmin -- --watch"
  },
  "tonicExampleFilename": "examples/runkit.js",
  "version": "1.1.0"
}
